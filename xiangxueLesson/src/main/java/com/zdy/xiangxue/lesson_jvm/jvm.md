helloWorld.java-->通过jvm编译成helloWorld.class加载到运行时数据区
在通过执行引擎，解释成计算机语言

1：java虚拟机运行时数据区的区域划分：
线程共享局域：方法区、堆
线程私有区域：虚拟机栈、本地方法栈、程序计数器
        程序计数器：当前线程正在执行的字节码的地址
        虚拟机栈：当前线程执行所需要的数据，指令与返回地址    （手枪子弹夹）
                栈帧包含局部变量表、操作数栈，动态链接与完成出口 （手枪子弹）
        本地方法栈：当前线程运行中的native方法信息



一个线程一个线程私有区域，一个方法一个栈帧，栈帧包含虚拟机栈（局部变量表，操作数栈，动态链接和完成出口）、本地方法栈和程序计数器

2：对象的创建过程
在对象new的过程中，类加载-->类的检查加载-->类的内存分配-->内存空间的初始化-->设置-->对象初始化
在类的内存分配中，考虑到内存划分的方式：1_指针碰撞 2_空闲列表 ，
考虑多线程：1_CAS原子失败重试 2：本地线程分配缓冲（TLAB）

3：对象的内存布局
对象头：
对象实例数据：
对象对齐填充：

4：判断对象的存活
1：引用计数法
   每次对象的引用都会去+1，去重引用会-1。但是存在对象相互引用，导致无法GC
2：可达性算法（根可达）
    对象是否直接关联GC-roots

注意：finalize关键字

5：对象的引用
强引用，弱引用，软引用，虚引用

6：对象的分配策略
栈上分配：是指java在执行过程中，在方法体重创建对象的时候直接从该方法所在的栈中分配空间

逃逸分析：一个方法创建的对象，除了在该方法内被引用外，在方法外也被引用；
这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其它变量引用。
正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。
static V global_v;
public void a_method(){
 V v=b_method();
 c_method();
}
public V b_method(){
 V v=new V();
 return v;
}
public void c_method(){
 global_v=new V();
}
其中b_method方法内部生成的V对象的引用被返回给a_method方法内的变量v，
c_method方法内生成的V对象被赋给了全局变量global_v。这两种场景都发生了（引用）逃逸。


分配策略：java虚拟机在分配对象空间的时候，首先判断是否需要栈上分配，判断的依据是是否存在对象逃逸
如果存在，则直接哎虚拟机栈中分配内存
如果不存在，则进行判断是否进行 本地线程分配缓冲（TLAB）
如果是，则直接在Eden去划分空间
如果否，则进行判断是否是大对象
如果是，则直接去老年代去分配空间，如果不是，则在eden去分配

分代收集理论：


8：垃圾回收
回收方法：
    复制：
        在eden区平分两块，每次使用一块，GC的时候，将不需要清理的放在另外一部分，然后清理剩下的，
        优点：没有碎片、实现简单、运行高效、
        缺点：空间利用率只有一半
    标记-清除
        分为标记和清除两个阶段
        先标记要清回收的对象，然后在清除
        缺点：标记和清除过程的效率都不高，产生大量碎片，内存碎片导致提前GC
    标记-整理
        先标记要清回收的对象，然后在清除，最后将未被回收的对象向一段移动，对齐
        缺点：对象移动 Ø 引用更新 Ø 用户线程暂停 Ø 没有内存碎片

    注意： 1、根据GC Roots标记处所有的可达对象
    2、并发标记所有具有可达性对象需要回收的对象
    3、将所有不可达的对象进行finalize判断
    4、finalize判断最终得到的才是需要清除的对象

常见的垃圾收集器：
单线程：

多线程并行：

多线程并发：

StopTheWorld:








